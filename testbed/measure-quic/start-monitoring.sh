#!/bin/bash -x
# 
# This source code is copyrighted by Montimage. It is released under MIT license.
# It is part of the French National Research Agency (ANR) MOSAICO project, under grant No ANR-19-CE25-0012.
#

# This script is to measure QUIC traffic
#
# Parameters are set via environment variables
# - info of the connection client_a -- server_a:
#    + BANDWIDTH_A  : bandwidth limited at the client side in Kbps (set 0 to unlimit)
#    + FILE_SIZE_A  : size of the file to be downloaded in MB (power by 1000 instead of 1024)
#    + TYPE_A       : "legit" or "unrespECN"
#    + START_TIME_A : sleep X second before starting
#    + DURATION_A   : active during X seconds before being killed
# - info of the connection client_b -- server_b 
#    + BANDWIDTH_B  :
#    + FILE_SIZE_B  :
#    + TYPE_B       : 
#    + START_TIME_B :
#    + DURATION_B   :


# create a dummy files with a given size on a given host
function create-dummy-files-on-servers(){
	run-on-host "$SERVER_A" truncate -s "${FILE_SIZE_A}MB" "/home/montimage/picoquic/picoquic/server_files/index-${FILE_SIZE_A}MB.htm"
	run-on-host "$SERVER_B" truncate -s "${FILE_SIZE_B}MB" "/home/montimage/picoquic/picoquic/server_files/index-${FILE_SIZE_B}MB.htm"
}

# this script will: delete all previous qdisc setup
# no parameter
# example:
#  reset-qdisc-off-all-vms
function reset-qdisc-off-all-vms(){
	run-on-host $CLIENT_A tc qdisc del dev $CLIENT_A_IFACE root
	run-on-host $CLIENT_B tc qdisc del dev $CLIENT_B_IFACE root
	run-on-host $SERVER_A tc qdisc del dev $SERVER_A_IFACE root
	run-on-host $SERVER_B tc qdisc del dev $SERVER_B_IFACE root
}

# limit traffic bandwidth at the clients
#  use https://github.com/magnific0/wondershaper
function limit-bandwidth(){
	log "limit bandwidth on $SERVER_A and $CLIENT_A: $BANDWIDTH_A Kbps"
	# bandwidth of uplink
	NO_LIMIT_BW=100000 #100 Mbps
	#clear limit
	run-on-host "$SERVER_A" sudo wondershaper clear "$SERVER_A_IFACE"
	run-on-host "$CLIENT_A" sudo wondershaper clear "$CLIENT_A_IFACE"

	#set limit only if it is not zero
	if [[ "$BANDWIDTH_A" != "0" ]]; then
		#syntax: wondershaper nic download-bw upload-bw
		run-on-host "$SERVER_A" sudo wondershaper "$CLIENT_A_IFACE" "$NO_LIMIT_BW"  "$BANDWIDTH_A" 
		run-on-host "$CLIENT_A" sudo wondershaper "$CLIENT_A_IFACE" "$BANDWIDTH_A"  "$NO_LIMIT_BW"
	fi

	log "limit bandwidth on $SERVER_B and $CLIENT_B: $BANDWIDTH_B Kbps"
	run-on-host "$SERVER_B" sudo wondershaper clear "$SERVER_B_IFACE"
	run-on-host "$CLIENT_B" sudo wondershaper clear "$CLIENT_B_IFACE"
	
	if [[ "$BANDWIDTH_B" != "0" ]]; then
		run-on-host "$SERVER_B" sudo wondershaper "$SERVER_B_IFACE" "$NO_LIMIT_BW"  "$BANDWIDTH_B"
		run-on-host "$CLIENT_B" sudo wondershaper "$CLIENT_B_IFACE" "$BANDWIDTH_B"  "$NO_LIMIT_BW"
	fi

	# print status
	run-on-host $CLIENT_A sudo wondershaper  $CLIENT_A_IFACE 
	run-on-host $CLIENT_B sudo wondershaper  $CLIENT_B_IFACE 
	run-on-host $SERVER_A sudo wondershaper  $SERVER_A_IFACE 
	run-on-host $SERVER_B sudo wondershaper  $SERVER_B_IFACE 
}


date
set -x

SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
# load predefined environment variables
. "$SCRIPT_PATH/../environment.sh"
MMT_CONFIG_FILE="$SCRIPT_PATH/mmt-probe.conf"

a=$((DURATION_A+START_TIME_A))
b=$((DURATION_B+START_TIME_B))
DURATION=$(( a > b ? a : b ))

# attributes to collect. They must be in syntax: proto.att_name as being defined by MMT
ATTRIBUTES=$(cat <<EOF
	"meta.packet_len",
	"ip.src", 
	"ip.dst", 
	"ip.proto_tos", 
	"ip.ecn",
	"ip.identification", 
	"udp.src_port", 
	"udp.dest_port",
	"udp.len",
	"quic_ietf.header_form",
	"quic_ietf.spin_bit",
	"int.hop_queue_ids",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.hop_tx_utilizes"
EOF
)
# NOTE: override "hop_tx_utilizes" to carry "int.mark_probability"


# the "name" of the attributes above to show as CSV header.
# They can be any string as you want
ATTRIBUTES_HEADERS=$(cat <<EOF
	"meta.packet_len",
	"ip.src", 
	"ip.dst", 
	"ip.proto_tos", 
	"ip.ecn",
	"ip.identification", 
	"udp.src_port", 
	"udp.dest_port",
	"udp.len",
	"quic_ietf.header_form",
	"quic_ietf.spin_bit",
	"int.hop_queue_ids",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.mark_probability"
EOF
)



function generate-config(){
	cat <<EOF
# Generated by script on $(date)
event-report int {
	enable = true
	# only capture UDP packet
	event  =  "meta.packet_index"
	delta-cond = {}
	attributes = { $ATTRIBUTES }
	output-channel = {file}
}
EOF
}

LOG_DIR="$PWD/log"
mkdir -p -- $LOG_DIR

# port of UDP on which QUIC uses
QUIC_UDP_PORT=4433

# current parameters
function print-parameters(){
cat <<EOF
[
	{
		"id":         "A",
		"server":     "$SERVER_A",
		"client":     "$CLIENT_A",
		"bandwidth":  "$BANDWIDTH_A Kbps",
		"file-size":  "$FILE_SIZE_A MB",
		"type":       "$TYPE_A",
		"start-time": "$START_TIME_A",
		"duration":   "$DURATION_A"
	},
	{
		"id":         "B",
		"server":     "$SERVER_B",
		"client":     "$CLIENT_B",
		"bandwidth":  "$BANDWIDTH_B Kbps",
		"file-size":  "$FILE_SIZE_B MB",
		"type":       "$TYPE_B",
		"start-time": "$START_TIME_B",
		"duration":   "$DURATION_B"
	}
]
EOF
}

function start-monitor(){
	cd -- "$LOG_DIR"
	duration=$((DURATION+20))
	# start pcap dumping
	log "start pcap dump"
	# capture only UDP traffic which is used to transport QUIC
	# store only the first 176 bytes that shoudl be enougth for ETH/IP/UDP/INT/QUIC-header
	timeout $duration tcpdump --snapshot-length=176 -i enp0s8  -w enp0s8-data.pcap udp &
	timeout $duration tcpdump --snapshot-length=176 -i enp0s10 -w enp0s10-int.pcap udp &
	sleep 1

	# generate config file
	cp -- "$MMT_CONFIG_FILE" ./mmt-probe.conf
	generate-config >> mmt-probe.conf

	log "start mmt-probe"
	timeout $duration mmt-probe -c ./mmt-probe.conf -i enp0s10 &
	sleep 5
}

function stop-monitor(){
	cd -- "$LOG_DIR"
	log "stop tcpdump and mmt-probe"
	killall --signal SIGINT tcpdump
	killall --signal SIGINT mmt-probe
	
	sleep 10

	tar -czf pcap.tar.gz enp0s8-data.pcap enp0s10-int.pcap
	# test to run mmt offline
	#mmt-probe -t enp0s10-int.pcap
	
	rm enp0s8-data.pcap enp0s10-int.pcap

	log "processing MMT files ..."
	HEADER=$(echo "report-id,probe-id,source,timestamp,report-name,meta.packet_index,$ATTRIBUTES_HEADERS" | tr -d '"' | tr -d "\n" | tr -d "[:blank:]" )
	echo "$HEADER" > data.csv
	for f in $(find . -name '1*.csv'); do
		echo " $f"
		#            only event reports
		#                             only port 4433 (?)
		cat "$f" | grep "^1000," | grep ",$QUIC_UDP_PORT," >> data.csv
		rm  -- "$f"
	done
	tar -czf data.csv.tar.gz data.csv
	#plot graph
	python "$SCRIPT_PATH/plot.py" data.csv
	rm data.csv
}

function clear-old-qlog-on-remotes(){
	run-on-all-endhost "rm -rf picoquic/picoquic/*log; rm -rf picoquic/picoquic/screenlog*"
}

# copy a qlog file from a VM, then extract necessaire info
# usage: copy-qlog $CLIENT_A
function copy-qlog(){
	host=$1
	output="$host.qlog"

	log "copy qlog file from $host to $output"
	cd -- "$LOG_DIR"
	
	# copy to the local machine
	( run-on-host "$host" "cat /home/montimage/picoquic/picoquic/*qlog" ) > "$output"
	
	# if we have the content
	# As the log of picoquic can be either in .qlog or .log file.
	#   thus we check whether it is in .qlog
	# Checks if file has size greater than 0
	if [[ -s "$output" ]]; then
		#if this is .qlog, we extract the info
		python "$SCRIPT_PATH/qlog-reader.py" "$output" "$output.csv"
	else
		#remove the empty file
		rm -rf -- "$output"
		output="$host.log"
		#somehow, picoquic does not generate .qlog but log
		( run-on-host "$host" "cat /home/montimage/picoquic/picoquic/*.log" ) > "$output"
	fi
	
	# compress to reduce storage space
	tar -czf "$output.tar.gz" "$output"
	#clean qlog files on this local machine and on the remote host
	rm -rf -- "$output"


}

function get-qlogs(){
	copy-qlog "$CLIENT_A"
	copy-qlog "$SERVER_A"
	copy-qlog "$CLIENT_B"
	copy-qlog "$SERVER_B"
}

function start-picoquic-servers(){
	log "run picoquic servers"
	#on server A
	duration=$((DURATION_A+10))
	run-on-host "$SERVER_A" "cd picoquic/picoquic && screen -S hn -L -dm timeout $duration ./launchquic.sh srv l4s $QUIC_UDP_PORT $TYPE_A verbose"
	
	#on server B
	duration=$((DURATION_B+10))
	run-on-host "$SERVER_B" "cd picoquic/picoquic && screen -S hn -L -dm timeout $duration ./launchquic.sh srv l4s $QUIC_UDP_PORT $TYPE_B verbose"
}

function start-picoquic-clients-and-wait-for-finish(){
	log "begin picoquic clients"
	( 
		sleep $START_TIME_A
		run-on-host "$CLIENT_A" "cd picoquic/picoquic && screen -S hn -L -dm timeout $DURATION_A ./launchquic.sh cli $SERVER_A $QUIC_UDP_PORT $TYPE_A $FILE_SIZE_A verbose"
	)&
	
	(
		sleep $START_TIME_B
		run-on-host "$CLIENT_B" "cd picoquic/picoquic && screen -S hn -L -dm timeout $DURATION_B ./launchquic.sh cli $SERVER_B $QUIC_UDP_PORT $TYPE_B $FILE_SIZE_B verbose"
	)&
	
	sleep 5
	sleep $DURATION
	sleep 5

	run-on-host "$CLIENT_A" "cat picoquic/picoquic/screenlog*"
	run-on-host "$CLIENT_B" "cat picoquic/picoquic/screenlog*"
	run-on-host "$SERVER_A" "cat picoquic/picoquic/screenlog*"
	run-on-host "$SERVER_B" "cat picoquic/picoquic/screenlog*"

	log "end picoquic clients"
}

function enable-ecn-on-remotes(){
	#run-on-all-endhost sudo sysctl -w net.ipv4.tcp_ecn=3
	run-on-host $CLIENT_A sudo sysctl -w net.ipv4.tcp_ecn=3
	run-on-host $SERVER_A sudo sysctl -w net.ipv4.tcp_ecn=3
	
	run-on-host $CLIENT_B sudo sysctl -w net.ipv4.tcp_ecn=3
	run-on-host $SERVER_B sudo sysctl -w net.ipv4.tcp_ecn=3
	
}

log "start experiment"

ps aux
run-on-all-endhost ps aux

log "$(print-parameters)"
print-parameters > "$LOG_DIR/param.json"

limit-bandwidth
clear-old-qlog-on-remotes
# QUIC does not use this config as it is on top of UDP
#enable-ecn-on-remotes
create-dummy-files-on-servers
start-picoquic-servers
start-monitor
start-picoquic-clients-and-wait-for-finish
stop-monitor
get-qlogs

log "end experiment"