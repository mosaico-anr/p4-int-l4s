#!/bin/bash -x
# 
# This source code is copyrighted by Montimage. It is released under MIT license.
# It is part of the French National Research Agency (ANR) MOSAICO project, under grant No ANR-19-CE25-0012.
#

# This script is to measure QUIC traffic
#
# Parameters are set via environment variables
# - info of the connection client_a -- server_a:
#    + BANDWIDTH  : bandwidth limited at the client side in Kbps
#    + TYPE       : "legit" or "unrespECN" or "iperf3"
#    + FILE_SIZE  : size of file to be downloaded, in MB

#SERVER=$SERVER_B
#CLIENT=$CLIENT_B
SERVER=192.168.1.105
CLIENT=192.168.1.103

# maximum 600 seconds
export DURATION=600

#export FILE_SIZE=1000
# create a dummy files with a given size on a given host
function create-dummy-files-on-servers(){
	run-on-host "$SERVER" truncate -s "${FILE_SIZE}MB" "picoquic/picoquic/server_files/index-${FILE_SIZE}MB.htm"
}

# this script will: delete all previous qdisc setup
# no parameter
# example:
#  reset-qdisc-off-all-vms
function reset-qdisc-off-all-vms(){
	run-on-host $CLIENT tc qdisc del dev $CLIENT_IFACE root
	run-on-host $SERVER tc qdisc del dev $SERVER_IFACE root
}

# limit traffic bandwidth at the clients
#  use https://github.com/magnific0/wondershaper
function limit-bandwidth(){
	log "limit bandwidth on $SERVER and $CLIENT: $BANDWIDTH Kbps"
	# bandwidth of uplink
	NO_LIMIT_BW=100000 #100 Mbps
	#clear limit
	run-on-host "$SERVER" sudo wondershaper clear "$SERVER_IFACE"
	run-on-host "$CLIENT" sudo wondershaper clear "$CLIENT_IFACE"

	#set limit only if it is not zero
	if [[ "$BANDWIDTH" != "0" ]]; then
		#syntax: wondershaper nic download-bw upload-bw
		run-on-host "$SERVER" sudo wondershaper "$SERVER_IFACE" "$NO_LIMIT_BW"  "$BANDWIDTH" 
		run-on-host "$CLIENT" sudo wondershaper "$CLIENT_IFACE" "$BANDWIDTH"    "$NO_LIMIT_BW"
	fi

	# print status
	run-on-host $CLIENT sudo wondershaper  $CLIENT_IFACE 
	run-on-host $SERVER sudo wondershaper  $SERVER_IFACE 
}


date
set -x

SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
# load predefined environment variables
. "$SCRIPT_PATH/../environment.sh"
MMT_CONFIG_FILE="$SCRIPT_PATH/mmt-probe.conf"

TCP_OR_UDP_ATTRIBUTES='"udp.src_port","udp.dest_port","udp.len"'
if [[ "$TYPE" == "iperf3" ]]; then
	TCP_OR_UDP_ATTRIBUTES='"tcp.src_port","tcp.dest_port","tcp.payload_len"'
fi
# attributes to collect. They must be in syntax: proto.att_name as being defined by MMT
ATTRIBUTES=$(cat <<EOF
	"meta.packet_len",
	"ip.src", 
	"ip.dst", 
	"ip.proto_tos", 
	"ip.ecn",
	"ip.identification", 
	$TCP_OR_UDP_ATTRIBUTES,
	"quic_ietf.header_form",
	"quic_ietf.spin_bit",
	"int.hop_queue_ids",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.hop_tx_utilizes"
EOF
)
# NOTE: override "hop_tx_utilizes" to carry "int.mark_probability"


# the "name" of the attributes above to show as CSV header.
# They can be any string as you want
ATTRIBUTES_HEADERS=$(cat <<EOF
	"meta.packet_len",
	"ip.src", 
	"ip.dst", 
	"ip.proto_tos", 
	"ip.ecn",
	"ip.identification", 
	$TCP_OR_UDP_ATTRIBUTES,
	"quic_ietf.header_form",
	"quic_ietf.spin_bit",
	"int.hop_queue_ids",
	"int.hop_latencies", 
	"int.hop_queue_occups",
	"int.hop_ingress_times", 
	"int.hop_egress_times",
	"int.hop_l4s_mark", 
	"int.hop_l4s_drop",
	"int.mark_probability"
EOF
)



function generate-config(){
	cat <<EOF
# Generated by script on $(date)
event-report int {
	enable = true
	# only capture UDP packet
	event  =  "meta.packet_index"
	delta-cond = {}
	attributes = { $ATTRIBUTES }
	output-channel = {file}
}
EOF
}

LOG_DIR="$PWD/log"
mkdir -p -- $LOG_DIR

# port of UDP on which QUIC uses
TCP_OR_UDP_PORT=4433

# current parameters
function print-parameters(){
cat <<EOF
{
	"server":     "$SERVER",
	"client":     "$CLIENT",
	"bandwidth":  "$BANDWIDTH Kbps",
	"type":       "$TYPE",
	"file-size":  "$FILE_SIZE MB"
}
EOF
}

function start-monitor(){
	cd -- "$LOG_DIR"
	duration=$((DURATION+20))
	# start pcap dumping
	log "start pcap dump"
	# capture only UDP traffic which is used to transport QUIC
	FILTER="port $TCP_OR_UDP_PORT"
	
	# store only first 128 bytes that should be nought for ETH/IP/UDP/QUIC-header
	timeout $duration tcpdump --snapshot-length=176 -i enp0s8  -w enp0s8-data.pcap $FILTER &
	# store only the first 176 bytes that should be enougth for ETH/IP/UDP/INT/QUIC-header
	timeout $duration tcpdump --snapshot-length=176 -i enp0s10 -w enp0s10-int.pcap $FILTER &
	sleep 1

	# generate config file
	cp -- "$MMT_CONFIG_FILE" ./mmt-probe.conf
	generate-config >> mmt-probe.conf

	log "start mmt-probe"
	timeout $duration mmt-probe -c ./mmt-probe.conf -i enp0s10 &
	sleep 5
}

function stop-monitor(){
	cd -- "$LOG_DIR"
	log "stop tcpdump and mmt-probe"
	killall --signal SIGINT tcpdump
	killall --signal SIGINT mmt-probe
	
	sleep 5

	tar -czf pcap.tar.gz enp0s8-data.pcap enp0s10-int.pcap
	# test to run mmt offline
	#mmt-probe -t enp0s10-int.pcap
	
	rm enp0s8-data.pcap enp0s10-int.pcap

	log "processing MMT files ..."
	HEADER=$(echo "report-id,probe-id,source,timestamp,report-name,meta.packet_index,$ATTRIBUTES_HEADERS" | tr -d '"' | tr -d "\n" | tr -d "[:blank:]" )
	echo "$HEADER" > data.csv

	for f in $(find . -name '1*.csv'); do
		echo " $f"
		#            only event reports
		cat "$f" | grep "^1000," | grep ",$TCP_OR_UDP_PORT," >> data.csv
		rm  -- "$f"
	done
	tar -czf data.csv.tar.gz data.csv
	#plot graph
	python "$SCRIPT_PATH/plot.py" data.csv
	rm data.csv
}

# copy a qlog file from a VM, then extract necessaire info
# usage: copy-qlog $CLIENT
function copy-qlog(){
	host=$1
	output="$host.qlog"

	log "copy qlog file from $host to $output"
	cd -- "$LOG_DIR"
	
	# copy to the local machine
	( run-on-host "$host" "cat picoquic/picoquic/*qlog" ) > "$output"
	
	# if we have the content
	# As the log of picoquic can be either in .qlog or .log file.
	#   thus we check whether it is in .qlog
	# Checks if file has size greater than 0
	if [[ -s "$output" ]]; then
		#if this is .qlog, we extract the info
		python "$SCRIPT_PATH/qlog-reader.py" "$output" "$output.csv"
	else
		#remove the empty file
		rm -rf -- "$output"
		output="$host.log"
		#somehow, picoquic does not generate .qlog but log
		( run-on-host "$host" "cat picoquic/picoquic/*.log" ) > "$output"
	fi
	
	# compress to reduce storage space
	tar -czf "$output.tar.gz" "$output"
	#clean qlog files on this local machine and on the remote host
	rm -rf -- "$output"
}

function get-qlogs(){
	copy-qlog "$CLIENT"
	copy-qlog "$SERVER"
}

function start-picoquic-servers(){
	log "run picoquic servers"
	#clean old log files
	run-on-host "$SERVER" "rm -rf picoquic/picoquic/*log; rm -rf picoquic/picoquic/screenlog*"
	#on server A
	duration=$((DURATION+10))
	run-on-host "$SERVER" "cd picoquic/picoquic && screen -S hn -L -dm timeout $duration ./launchquic.sh srv l4s $TCP_OR_UDP_PORT $TYPE_A verbose"
}


function start-picoquic-clients-and-wait-for-finish(){
	log "begin picoquic clients"
	#clean old log files
	run-on-host "$CLIENT" "rm -rf picoquic/picoquic/*log; rm -rf picoquic/picoquic/screenlog*"
	
	sleep 5
	run-on-host "$CLIENT" "cd picoquic/picoquic && screen -S hn -L -dm timeout $DURATION ./launchquic.sh cli $SERVER $TCP_OR_UDP_PORT $TYPE $FILE_SIZE verbose"
	
	sleep $DURATION
	sleep 5

	run-on-host "$CLIENT" "cat picoquic/picoquic/screenlog*"
	run-on-host "$SERVER" "cat picoquic/picoquic/screenlog*"

	log "end picoquic clients"
}


function start-iperf3-servers(){
	log "configuration server VM"
	# activate tcp-prage
	run-on-host $SERVER sudo sysctl -w net.ipv4.tcp_congestion_control=prague
	# Enable Accurate ECN
	run-on-host $CLIENT sudo sysctl -w net.ipv4.tcp_ecn=3
	
	log "start iperf3 server"
	duration=$((DURATION+10))
	run-on-host "$SERVER" "cd /tmp/ && screen -S hn -L -dm timeout $duration iperf3 -s --one-off --port $TCP_OR_UDP_PORT"
}


function start-iperf3-clients-and-wait-for-finish(){
	#clean old log files
	run-on-host "$CLIENT" "rm -rf /tmp/screenlog*"
	run-on-host "$SERVER" "rm -rf /tmp/screenlog*"
	
	log "configuration iperf3 client VM"
	
	run-on-host $SERVER sudo sysctl -w net.ipv4.tcp_congestion_control=prague
	run-on-host $CLIENT sudo sysctl -w net.ipv4.tcp_ecn=3
	
	log "begin iperf3 clients"
	
	sleep 5
	
	run-on-host "$CLIENT" "cd /tmp/ && screen -S hn -L -dm iperf3 -c $SERVER --bandwidth ${BANDWIDTH}K --set-mss 1400 --length 1400 --time $DURATION --port $TCP_OR_UDP_PORT"
	
	sleep $DURATION
	sleep 5

	#print execution logs of iperf3 client and server,
	run-on-host "$CLIENT" "cat /tmp/screenlog*; rm -rf /tmp/screenlog*"
	run-on-host "$SERVER" "cat /tmp/screenlog*; rm -rf /tmp/screenlog*"

	log "end iperf3 clients"
}


log "start experiment"

# to verify which processes are running
ps aux
run-on-all-endhost ps aux

log "$(print-parameters)"
print-parameters > "$LOG_DIR/param.json"

limit-bandwidth

if [[ "$TYPE" == "iperf3" ]]; then
	start-iperf3-servers
	start-monitor
	start-iperf3-clients-and-wait-for-finish
	stop-monitor
else 
	create-dummy-files-on-servers
	start-picoquic-servers
	start-monitor
	start-picoquic-clients-and-wait-for-finish
	stop-monitor
	get-qlogs
fi

log "end experiment"